# Generated by CodiumAI
from asyncio import sleep
import csv
from unittest import TestCase
from unittest.mock import MagicMock, patch

import bs4
from DataAnalytics.bstracker import  get_actual_team_byname, get_data_race, get_standings, get_standings_teams, next_race_scrapping, post_data_driver
import urllib3 as urllib
from pyspark.sql import SparkSession
import io
from unittest.mock import patch, mock_open
# Dependencies:
# pip install pytest-mock
import pytest

"""
Code Analysis

Objective:
The objective of the 'race_scrapping' function is to scrape the podium finishers and the pole position of a race from a given URL using web scraping techniques. The function returns a list of tuples containing the position and name of the podium finishers, and the name of the driver who achieved the pole position.

Inputs:
The function takes a single input parameter 'url', which is the URL of the webpage containing the race results.

Flow:
The function first opens the URL using the 'urllib.request.urlopen' method and creates a BeautifulSoup object to parse the HTML content of the webpage. It then searches for the table with class 'infobox vevent' and extracts the podium finishers' names and positions using the 'find_all' method. The function then appends the podium finishers' names and positions to a list of tuples and returns the list along with the name of the driver who achieved the pole position.

Outputs:
The function returns a list of tuples containing the position and name of the podium finishers and the name of the driver who achieved the pole position.

Additional aspects:
The function uses the BeautifulSoup library to parse the HTML content of the webpage and extract the required information. It also uses the 'urllib.request.urlopen' method to open the URL and retrieve the HTML content. The function assumes that the webpage contains a table with class 'infobox vevent' and that the podium finishers' names and positions are contained within a 'div' tag with class 'plainlist'.
"""

class TestRaceScrapping(TestCase):

    def test_happy_path_get_actual_team_byname(self):
        # Arrange
        expected_team = "Mercedes"
        name = "Hamilton"
        html = f'<fieldset class="listing-item-wrapper"><span class="f1-color--black">{expected_team}</span><span class="last-name f1-uppercase f1-bold--xs d-block d-lg-inline">{name}</span></fieldset>'
        
        mock_response = MagicMock()
        mock_response.read.return_value = html.encode()  # Convertir a bytes
        mock_urlopen = MagicMock(return_value=mock_response)
        
        with patch('DataAnalytics.bstracker.urllib.request.urlopen', mock_urlopen):
            # Act
            actual_team = get_actual_team_byname(name)
            
            # Assert
            assert actual_team == expected_team

        


    

    def test_edge_case_empty_name(self):
        # Arrange
        name = ""
        
        # Act
        actual_team = get_actual_team_byname(name)
        
        # Assert
        assert actual_team is None
    
        # Tests that the function successfully retrieves and parses data from a valid URL.


        # Tests that the function returns data and speeds when given valid inputs.
    @patch('DataAnalytics.bstracker.get_positions')
    @patch('DataAnalytics.bstracker.get_speeds')
    def test_valid_input(self, mock_get_speeds, mock_get_positions):
        # Mocking the get_positions and get_speeds functions
        mock_get_positions.return_value = [['1', 'Lewis Hamilton', 'Mercedes', '1:30:17.194', '25'], ['2', 'Max Verstappen', 'Red Bull Racing Honda', '+8.800s', '18']]
        mock_get_speeds.return_value = [['1', 'Max Verstappen', 'Red Bull Racing Honda', '1:18.149']]
        
        data, speeds = get_data_race(2021, 'Spain', 'Spanish Grand Prix')
        
        assert data == [['1', 'Lewis Hamilton', 'Mercedes', '1:30:17.194', '25'], ['2', 'Max Verstappen', 'Red Bull Racing Honda', '+8.800s', '18']]
        assert speeds == [['1', 'Max Verstappen', 'Red Bull Racing Honda', '1:18.149']]

    from bs4 import BeautifulSoup

    @patch('DataAnalytics.bstracker.urllib.request.urlopen')
    def test_get_standings_happy(self, mocker):
        # Happy path test
        # Mock the urllib.request.urlopen function to return a sample HTML table
        sample_html = """
            <table class="resultsarchive-table">
                <tr>
                    <td><span>1</span></td>
                    <td><span>Lewis Hamilton</span></td>
                    <td><span>Mercedes</span></td>
                    <td><span>GBR</span></td>
                    <td><span>413</span></td>
                </tr>
                <tr>
                    <td><span>2</span></td>
                    <td><span>Max Verstappen</span></td>
                    <td><span>Red Bull Racing Honda</span></td>
                    <td><span>NED</span></td>
                    <td><span>326</span></td>
                </tr>
            </table>
        """
        
        mock_response = MagicMock()
        mock_response.read.return_value = sample_html.encode()  # Convertir a bytes
        mock_urlopen = MagicMock(return_value=mock_response)
        
        with patch('DataAnalytics.bstracker.urllib.request.urlopen', mock_urlopen):

        # Call the function and check the output
            res, _, _ = get_standings()

            
            assert res == [['2', 'Max Verstappen', 'Red Bull Racing Honda', 'NED', '326']]
            
        # Tests that the function correctly extracts the team names and standings from the retrieved data.
    @patch('DataAnalytics.bstracker.urllib.request.urlopen')
    def test_correct_extraction(self, mocker):
        # Mocking the urllib.request.urlopen function to return a sample HTML page
        html = """
        <table class="resultsarchive-table">
            <tr>
                <td><span>1</span></td>
                <td><a href="/en/teams/Mercedes.html">Mercedes</a></td>
                <td>44</td>
            </tr>
            <tr>
                <td><span>2</span></td>
                <td><a href="/en/teams/Red_Bull_Racing.html">Red Bull Racing</a></td>
                <td>33</td>
            </tr>
        </table>
        """
        #mocker.patch('urllib.request.urlopen', return_value=html)
        mock_response = MagicMock()
        mock_response.read.return_value = html.encode()  # Convertir a bytes
        mock_urlopen = MagicMock(return_value=mock_response)
        
        with patch('DataAnalytics.bstracker.urllib.request.urlopen', mock_urlopen):
        # Expected output
            expected_names = [['2', 'Red Bull Racing', '33']]

            # Calling the function
            _, names, _ = get_standings_teams()

            # Assertions
            assert names == expected_names
